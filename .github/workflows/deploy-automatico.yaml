name: Frota Deploy (Release)
on:
  release:
    types: [published]
  workflow_dispatch:

jobs:
  test:
    runs-on: windows-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '8.0'
    
    - name: Restore test dependencies
      run: |
        cd "Codigo\Frota - web api\ServiceTests"
        dotnet restore
    
    - name: Run tests
      run: |
        cd "Codigo\Frota - web api\ServiceTests"
        dotnet test --configuration Release --no-restore --verbosity normal

  test-web:
    runs-on: windows-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '8.0'
    
    - name: Restore web test dependencies
      run: |
        cd "Codigo\Frota - web api\FrotaWebTests"
        dotnet restore
    
    - name: Run web tests
      run: |
        cd "Codigo\Frota - web api\FrotaWebTests"
        dotnet test --configuration Release --no-restore --verbosity normal

  build-and-deploy-api:
    needs: test
    runs-on: windows-latest
    
    env:
      work-directory: "Codigo/Frota - web api/FrotaApi"
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '8.0'
    
    # Debug: Verificar estrutura de arquivos da API
    - name: Debug - List API files
      run: |
        echo "=== Verificando estrutura da API ==="
        echo "Work directory: ${{env.work-directory}}"
        if (Test-Path "${{env.work-directory}}") {
          echo "‚úÖ Pasta da API existe!"
          echo "Arquivos na pasta:"
          Get-ChildItem "${{env.work-directory}}" | Select-Object Name, Length
          echo "Procurando appsettings.json:"
          Get-ChildItem "${{env.work-directory}}" -Filter "appsettings.json" | Select-Object FullName
        } else {
          echo "‚ùå Pasta da API n√£o existe!"
          echo "Procurando FrotaApi em todo o reposit√≥rio:"
          Get-ChildItem -Recurse -Include "FrotaApi" -Directory | Select-Object FullName
        }
    
    # Substitui a connection string do MySQL para produ√ß√£o
    - name: Replace connection string
      uses: microsoft/variable-substitution@v1
      with:
        files: '${{env.work-directory}}/appsettings.json'
      env:
        ConnectionStrings.MySqlConnection: ${{secrets.CONNECTION_STRING}}
    
    - name: Restore dependencies
      run: |
        cd "${{env.work-directory}}"
        dotnet restore
    
    - name: Build API
      run: |
        cd "${{env.work-directory}}"
        dotnet build --configuration Release --no-restore
    
    - name: Publish API
      run: |
        cd "${{env.work-directory}}"
        dotnet publish --configuration Release --no-build --output ./publishAPI
    
    # ETAPA 1: App_Offline para parar a API
    - name: Create and Deploy App_Offline for API
      run: |
        cd "${{env.work-directory}}/publishAPI"
        # Copia a p√°gina de offline personalizada se existir, sen√£o cria uma padr√£o
        if (Test-Path "../../.github/templates/app_offline_api.htm") {
          Copy-Item "../../.github/templates/app_offline_api.htm" -Destination "app_offline.htm"
          Write-Host "‚úÖ Usando p√°gina de offline personalizada para API"
        } else {
          echo "<!DOCTYPE html><html><head><meta charset='utf-8'><title>API Frota em Manuten√ß√£o</title></head><body><h1>API Frota em Manuten√ß√£o</h1><p>A API est√° sendo atualizada. Voltaremos em instantes...</p></body></html>" > app_offline.htm
          Write-Host "‚ö†Ô∏è Usando p√°gina de offline padr√£o para API"
        }
        
        # Upload apenas o app_offline.htm via PowerShell FTP
        $ftpServer = "win8184.site4now.net"
        $ftpUsername = "itetech-001"
        $ftpPassword = $env:FTP_PASSWORD
        $localFile = "app_offline.htm"
        $remoteFile = "/frotaapi/app_offline.htm"
        
        if ([string]::IsNullOrEmpty($ftpPassword)) {
          Write-Host "‚ùå FTP_PASSWORD est√° vazio ou n√£o definido!"
          throw "FTP_PASSWORD n√£o encontrado"
        }
        
        try {
          $ftpRequest = [System.Net.FtpWebRequest]::Create("ftp://$ftpServer$remoteFile")
          $ftpRequest.Method = [System.Net.WebRequestMethods+Ftp]::UploadFile
          $ftpRequest.Credentials = New-Object System.Net.NetworkCredential($ftpUsername, $ftpPassword)
          $ftpRequest.UseBinary = $true
          $ftpRequest.UsePassive = $true
          
          $fileContent = Get-Content $localFile -Raw -Encoding UTF8
          $data = [System.Text.Encoding]::UTF8.GetBytes($fileContent)
          
          $ftpRequest.ContentLength = $data.Length
          $requestStream = $ftpRequest.GetRequestStream()
          $requestStream.Write($data, 0, $data.Length)
          $requestStream.Close()
          
          $response = $ftpRequest.GetResponse()
          Write-Host "‚úÖ App_Offline da API enviado com sucesso!"
          $response.Close()
        }
        catch {
          Write-Host "‚ùå Erro ao enviar App_Offline da API: $($_.Exception.Message)"
          throw
        }
      env:
        FTP_PASSWORD: ${{ secrets.FTP_PASSWORD }}
    
    # ETAPA 2: Aguardar API parar
    - name: Wait for API to stop
      run: Start-Sleep -Seconds 20
    
    # ETAPA 3: Deploy da API
    - name: Deploy API Files
      uses: SamKirkland/FTP-Deploy-Action@v4.3.4
      with:
        server: win8184.site4now.net
        username: itetech-001
        password: ${{ secrets.FTP_PASSWORD }}
        local-dir: '${{env.work-directory}}/publishAPI/'
        server-dir: /frotaapi/
        exclude: |
          **/.git*
          **/.git*/**
          **/obj/**
          **/bin/**
          app_offline.htm
    
    # ETAPA 4: Remover App_Offline para reativar a API
    - name: Remove App_Offline from API
      run: |
        $ftpServer = "win8184.site4now.net"
        $ftpUsername = "itetech-001"
        $ftpPassword = $env:FTP_PASSWORD
        $remoteFile = "/frotaapi/app_offline.htm"
        
        try {
          $ftpRequest = [System.Net.FtpWebRequest]::Create("ftp://$ftpServer$remoteFile")
          $ftpRequest.Method = [System.Net.WebRequestMethods+Ftp]::DeleteFile
          $ftpRequest.Credentials = New-Object System.Net.NetworkCredential($ftpUsername, $ftpPassword)
          $ftpRequest.UsePassive = $true
          
          $response = $ftpRequest.GetResponse()
          Write-Host "‚úÖ App_Offline da API removido com sucesso!"
          $response.Close()
        }
        catch {
          Write-Host "‚ö†Ô∏è Erro ao remover App_Offline da API (pode j√° ter sido removido): $($_.Exception.Message)"
        }
      env:
        FTP_PASSWORD: ${{ secrets.FTP_PASSWORD }}
    
    # ETAPA 5: Verificar se a API voltou
    - name: Verify API is back online
      run: |
        Write-Host "üîç Verificando se a API voltou ao normal..."
        Start-Sleep -Seconds 10
        try {
          # Teste b√°sico na API
          $response = Invoke-WebRequest -Uri "http://itetech-001-site1.qtempurl.com" -TimeoutSec 30
          Write-Host "‚úÖ API est√° online - Status: $($response.StatusCode)"
        }
        catch {
          Write-Host "‚ö†Ô∏è API ainda pode estar reiniciando: $($_.Exception.Message)"
          Write-Host "Tentando endpoint espec√≠fico da API..."
          try {
            # Tente um endpoint espec√≠fico da sua API aqui, como /api/health ou /swagger
            $healthResponse = Invoke-WebRequest -Uri "http://itetech-001-site1.qtempurl.com/swagger" -TimeoutSec 30
            Write-Host "‚úÖ Swagger da API est√° acess√≠vel - Status: $($healthResponse.StatusCode)"
          }
          catch {
            Write-Host "‚ö†Ô∏è Endpoints da API ainda n√£o est√£o respondendo. Isso pode ser normal durante o restart."
          }
        }

  build-and-deploy-web:
    needs: [test, test-web]
    runs-on: windows-latest
    
    env:
      work-directory: "Codigo/Frota - web api/FrotaWeb"
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '8.0'
    
    # Debug: Verificar estrutura de arquivos da Web
    - name: Debug - List Web files
      run: |
        echo "=== Verificando estrutura da Web ==="
        echo "Work directory: ${{env.work-directory}}"
        if (Test-Path "${{env.work-directory}}") {
          echo "‚úÖ Pasta da Web existe!"
          echo "Arquivos na pasta:"
          Get-ChildItem "${{env.work-directory}}" | Select-Object Name, Length
          echo "Procurando appsettings.json:"
          Get-ChildItem "${{env.work-directory}}" -Filter "appsettings.json" | Select-Object FullName
        } else {
          echo "‚ùå Pasta da Web n√£o existe!"
          echo "Procurando FrotaWeb em todo o reposit√≥rio:"
          Get-ChildItem -Recurse -Include "FrotaWeb" -Directory | Select-Object FullName
        }
    
    # Substitui a connection string do MySQL para produ√ß√£o
    - name: Replace connection string
      uses: microsoft/variable-substitution@v1
      with:
        files: '${{env.work-directory}}/appsettings.json'
      env:
        ConnectionStrings.MySqlConnection: ${{secrets.CONNECTION_STRING}}
    
    - name: Restore dependencies
      run: |
        cd "${{env.work-directory}}"
        dotnet restore
    
    - name: Build Web
      run: |
        cd "${{env.work-directory}}"
        dotnet build --configuration Release --no-restore
    
    - name: Publish Web
      run: |
        cd "${{env.work-directory}}"
        dotnet publish --configuration Release --no-build --output ./publishWeb
    
    # ETAPA 1: App_Offline para parar a Web
    - name: Create and Deploy App_Offline for Web
      run: |
        cd "${{env.work-directory}}/publishWeb"
        # Copia a p√°gina de offline personalizada se existir, sen√£o cria uma padr√£o
        if (Test-Path "../../.github/templates/app_offline_web.htm") {
          Copy-Item "../../.github/templates/app_offline_web.htm" -Destination "app_offline.htm"
          Write-Host "‚úÖ Usando p√°gina de offline personalizada para Web"
        } else {
          echo "<!DOCTYPE html><html><head><meta charset='utf-8'><title>Sistema Frota em Manuten√ß√£o</title></head><body><h1>Sistema de Gest√£o de Frota em Manuten√ß√£o</h1><p>O sistema est√° sendo atualizado. Voltaremos em instantes...</p></body></html>" > app_offline.htm
          Write-Host "‚ö†Ô∏è Usando p√°gina de offline padr√£o para Web"
        }
        
        # Upload apenas o app_offline.htm via PowerShell FTP
        $ftpServer = "win8184.site4now.net"
        $ftpUsername = "itetech-001"
        $ftpPassword = $env:FTP_PASSWORD
        $localFile = "app_offline.htm"
        $remoteFile = "/frotaweb/app_offline.htm"
        
        if ([string]::IsNullOrEmpty($ftpPassword)) {
          Write-Host "‚ùå FTP_PASSWORD est√° vazio ou n√£o definido!"
          throw "FTP_PASSWORD n√£o encontrado"
        }
        
        try {
          $ftpRequest = [System.Net.FtpWebRequest]::Create("ftp://$ftpServer$remoteFile")
          $ftpRequest.Method = [System.Net.WebRequestMethods+Ftp]::UploadFile
          $ftpRequest.Credentials = New-Object System.Net.NetworkCredential($ftpUsername, $ftpPassword)
          $ftpRequest.UseBinary = $true
          $ftpRequest.UsePassive = $true
          
          $fileContent = Get-Content $localFile -Raw -Encoding UTF8
          $data = [System.Text.Encoding]::UTF8.GetBytes($fileContent)
          
          $ftpRequest.ContentLength = $data.Length
          $requestStream = $ftpRequest.GetRequestStream()
          $requestStream.Write($data, 0, $data.Length)
          $requestStream.Close()
          
          $response = $ftpRequest.GetResponse()
          Write-Host "‚úÖ App_Offline da Web enviado com sucesso!"
          $response.Close()
        }
        catch {
          Write-Host "‚ùå Erro ao enviar App_Offline da Web: $($_.Exception.Message)"
          throw
        }
      env:
        FTP_PASSWORD: ${{ secrets.FTP_PASSWORD }}
    
    # ETAPA 2: Aguardar Web parar
    - name: Wait for Web to stop
      run: Start-Sleep -Seconds 20
    
    # ETAPA 3: Deploy da Web
    - name: Deploy Web Files
      uses: SamKirkland/FTP-Deploy-Action@v4.3.4
      with:
        server: win8184.site4now.net
        username: itetech-001
        password: ${{ secrets.FTP_PASSWORD }}
        local-dir: '${{env.work-directory}}/publishWeb/'
        server-dir: /frotaweb/
        exclude: |
          **/.git*
          **/.git*/**
          **/obj/**
          **/bin/**
          app_offline.htm
    
    # ETAPA 4: Remover App_Offline para reativar a Web
    - name: Remove App_Offline from Web
      run: |
        $ftpServer = "win8184.site4now.net"
        $ftpUsername = "itetech-001"
        $ftpPassword = $env:FTP_PASSWORD
        $remoteFile = "/frotaweb/app_offline.htm"
        
        try {
          $ftpRequest = [System.Net.FtpWebRequest]::Create("ftp://$ftpServer$remoteFile")
          $ftpRequest.Method = [System.Net.WebRequestMethods+Ftp]::DeleteFile
          $ftpRequest.Credentials = New-Object System.Net.NetworkCredential($ftpUsername, $ftpPassword)
          $ftpRequest.UsePassive = $true
          
          $response = $ftpRequest.GetResponse()
          Write-Host "‚úÖ App_Offline da Web removido com sucesso!"
          $response.Close()
        }
        catch {
          Write-Host "‚ö†Ô∏è Erro ao remover App_Offline da Web (pode j√° ter sido removido): $($_.Exception.Message)"
        }
      env:
        FTP_PASSWORD: ${{ secrets.FTP_PASSWORD }}
    
    # ETAPA 5: Verificar se a Web voltou
    - name: Verify Web is back online
      run: |
        Write-Host "üîç Verificando se a aplica√ß√£o Web voltou ao normal..."
        Start-Sleep -Seconds 10
        try {
          # Teste b√°sico na aplica√ß√£o Web
          $response = Invoke-WebRequest -Uri "http://itetech-001-site5.qtempurl.com" -TimeoutSec 30
          Write-Host "‚úÖ Aplica√ß√£o Web est√° online - Status: $($response.StatusCode)"
        }
        catch {
          Write-Host "‚ö†Ô∏è Aplica√ß√£o Web ainda pode estar reiniciando: $($_.Exception.Message)"
          Write-Host "Tentando endpoint espec√≠fico da aplica√ß√£o..."
          try {
            # Tente a p√°gina inicial ou login
            $homeResponse = Invoke-WebRequest -Uri "http://itetech-001-site5.qtempurl.com/Home" -TimeoutSec 30
            Write-Host "‚úÖ P√°gina inicial da aplica√ß√£o est√° acess√≠vel - Status: $($homeResponse.StatusCode)"
          }
          catch {
            Write-Host "‚ö†Ô∏è Endpoints da aplica√ß√£o ainda n√£o est√£o respondendo. Isso pode ser normal durante o restart."
          }
        }